# 1. 요구 사항 확인

| 단어                          | 내용                                                         | 기타                                                         |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| SDLC                          | 시스템의 요구분석 ~ 유지보수까지 전 과정을 모델링 한 것      |                                                              |
| SDLC 모델 종류                | 1. 폭포수 모델(Waterfall Model)<br />2. 프로토타이핑 모델(Prototyping Model)<br />3. 나선형 모델(Spiral Model)<br />4. 반복적 모델(Iteration Model) |                                                              |
| 폭포수 모델                   | - 선형 순차적 모델 => 고전적 생명주기 모델<br />- 각 개발 단계를 마무리 지은 후 넘어가는 모델<br />- 가장 오래됐고, 성공사례가 많으며, 단계별 산출물이 명확하고 요구사항 변경이 어려움 |                                                              |
| 프로토타이핑 모델             | - 주요 기능을 프로토타입으로 구현<br />- 피드백을 반영해 만들어나가는 모델 |                                                              |
| 나선형 모델                   | - 위험을 최소화하기 위해, 점진적으로 개발해나가는 모델<br />- 절차: 계획 및 정의 -> 위험 분석 -> 개발 -> 고객 평가 |                                                              |
| 반복적 모델                   | 병렬적으로 개발 후 통합하거나, 반복적으로 개발해 점차 완성시켜나가는 모델 |                                                              |
|                               |                                                              |                                                              |
| 소프트웨어 개발 방법론        | 소프트웨어의 개발 시작부터 전 개발 과정을 형상화한 방법론<br />1. 구조적 방법론<br />2. 정보공학 방법론<br />3. 객체지향 방법론<br />4. 컴포넌트 기반 방법론<br />5. 애자일 방법론<br />6. 제품 계열 방법론 |                                                              |
| 구조적 방법론                 | - 전체 시스템을 나눠 개발하고 통합하는 분할-정복 방식의 방법론<br />- nassi shneiderman diagram 사용 | ![나씨 슈나이더만 도표(Nassi–Shneiderman diagram) : 네이버 블로그](assets/images.png) |
| 정보공학 방법론               | - 정보 시스템 개발에 필요한 절차를 체계화한 방법론<br />- 대형 프로젝트에서 사용 |                                                              |
| 객체지향 방법론               | - 객체라는 단위로 시스템을 설계하는 방법론                   |                                                              |
| 컴포넌트 기반 방법론          | - 컴포넌트를 조립해 작성하는 방법론                          |                                                              |
| 애자일 방법론                 | - 정차보다 사람이 우선되는 변화에 유연한 경량 개발 방법론    |                                                              |
| 제품 계열 방법론              | - 제품에 적용할 공통 기능을 정의하여 개발하는 방법론         |                                                              |
|                               |                                                              |                                                              |
| XP                            | 1~3주의 반복(Iteration) 주기를 갖는 애자일 방법론            |                                                              |
| XP의 5가지 가치               | 1. 용기<br />2. 단순성<br />3. 의사소통<br />4. 피드백<br />5. 존중 |                                                              |
| XP의 12가지 기본 원리         | 1. 짝 프로그래맹 (Pair Programming) : 다른 사람과 페어로 개발하여 공동 책임을 지님<br />2. 공동 코드 소유 (Collective Ownership) : 시스템에 있는 코드는 누구나 언제든 수정 가능<br />3. 지속적인 통합 (Continuos Integration) : 여러 번 소프트웨어를 통합하고 빌드해야 함<br />4. 계획 세우기(Planning Proceess) : 고객이 원하는 가치를 정의하고, 개발에 필요한 건 무엇이며, 어떤 곳에서 지연이 될 수 있는지 알려줘야함<br />5. 작은 릴리즈 (Small Release) : 작은 시스템을 먼저 만들고, 짧은 단위로 업데이트<br />6. 메타포어 (Metaphor) :  공통 이름 체계를 통해 의사소통을 원할히<br />7. 산단한 디자인 (Simple Design) : 요구사항에 적합한 단순한 시스템을 설계<br />8. 테스트 기반 개발 (Test Driven Develop) : 테스트를 먼저 수행하고, 통과할 수 있는 코드를 작성<br />9. 리팩토링 (Refactoring) : 기능을 바꾸지 않으면서 중복제거, 단순화 등을 위해 코드를 재구성<br />10. 40시간 작업 (40-Hour Work) : 피곤으로 인한 실수가 없도록 주 40시간만 일합시다<br />11. 고객 상주 (On Site Customer) : 개발자들의 질문에 즉각 대답해줄 수 있는 고객이 풀타임 상주해야 함<br />12. 코드 표준 (Coding Standard) : 코딩 표준을 두고 효과적으로 개발 |                                                              |
|                               |                                                              |                                                              |
| 스크럼                        | 매일 정해진 시간/장소에서 짧은 시간의 개발을 위한 애자일 방법론<br />- 백로그 : 제품에 대한 요구사항<br />- 스프린트 : 짧은 기간 내 반복적으로 으쌰으쌰<br />- 데일리(스크럼) 미팅 : 매일 To-Do List 계획수립, 번다운 차트 작성<br />- 스크럼 마스터 : 프로젝트 리더<br />- 스프린트 회고 : 각자 반성하고 개선점 확인<br />- 번 다운 차트 : 남아있는 백로그 대비 시간을 시각적으로 표현 (백로그를 수직, 시간을 수평) | ![번다운 차트에 관한 모든 것과 번다운 차트 템플릿](data:image/jpeg;base64,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) |
|                               |                                                              |                                                              |
| 린                            | 낭비 요소를 제거해 품질을 향상시키는 애자일 방법론<br />1. 낭비제거<br />2. 품질 내재화<br />3. 지식 창출<br />4. 늦은 확정<br />5. 빠른 인도<br />6. 사람 존중<br />7. 전체 최적화 |                                                              |
|                               |                                                              |                                                              |
| 소프트웨어 아키텍처 패턴 종류 | 1. 계층화 패턴<br />2. 클라이언트-서버 패턴<br />3. 파이프-필터 패턴<br />4. 브로커 패턴<br />5. 모델-뷰-컨트롤러 패턴 |                                                              |
| 계층화 패턴                   | - 시스템을 계층으로 구분 ex) OSI 7계층<br />- 서로 마주보는 계층에서만 상호작용 발생 |                                                              |
| 클라이언트-서버 패턴          | - 하나의 서버 + 다수의 클라이언트<br />- 사용자는 클라이언트와만 상호작용 |                                                              |
| 파이프-필터 패턴              | - 데이터 스트림을 처리하는 시스템에서 사용 ex) Unix의 Shell<br />- 하나의 서브시스템이 데이터를 받아 처리하고, 결과를 다음 서브 시스템에게 넘겨줌 |                                                              |
| 브로커 패턴                   | - 사용자가 요청하면, 브로커가 적합한 컴포넌트를 연결하는 방식<br />- 원격 서비스 호출에 응답하는 컴포넌트가 여럿일 때 적합 |                                                              |
| MVC 패턴                      | - 하나의 모델에 여러 개의 뷰를 필요로하는 대화형 어플리케이션에 적합<br />- 모델 : 핵심 기능과 데이터 보관<br />- 뷰 : 사용자에게 정보 표시<br />- 컨트롤러 : 사용자의 입력 처리 |                                                              |
|                               |                                                              |                                                              |
| 디자인 패턴 - 생성패턴        | 1. 팩토리 메소드 (Factory Method)<br />2. 프로토타입 (Prototype)<br />3. 빌더 (Builder)<br />4. 싱글톤 (Singletone)<br />5. 추상 팩토리 (Abstract Factory) |                                                              |
| 팩토리 메소드                 | - 상위 클래스에서 인터페이스 정의<br />- 서브 클래스가 실제 생성 |                                                              |
| 프로토타입                    | - 원형 객체를 복사하여 생성<br />- 객체 생성 시 갖춰야할 기본 형태가 있을 때 사용 |                                                              |
| 빌더                          | - 객체를 조립하여 생성<br />- 생성 방법과 구현 방법을 구분하여, 동일한 객체 생성이여도 다른 결과가 나올 수 있음 |                                                              |
| 싱글톤                        | - 클래스 내 객체가 하나 뿐임을 보장.<br />- 하나의 객체를 생성해 어디든 참조할 수 있으나 동시 참조 불가 |                                                              |
| 추상 팩토리                   | - 구체적인 클래스에 의존하지 않고, 연관된 객체들의 그룹으로 생성<br />- 객체간 결합이 느슨해짐 |                                                              |
|                               |                                                              |                                                              |
| 디자인 패턴 - 구조 패턴       | 1. 퍼싸드 (Facade)<br />2.  플라이웨이트 (Flyweight)<br />3. 컴포지트 (Composite)<br />4. 브리지 (Bridge)<br />5. 어댑터 (Adapter)<br />6. 데코레이터 (Decorator)<br />7. 프록시 |                                                              |
| 퍼싸드                        | - 복잡한 시스템에 단순한 인터페이스를 제공해 접근성을 높인 패턴 |                                                              |
| 플라이웨이트                  | - 객체가 필요할 때 생성하는 대신 공유하여 메모리 절약        |                                                              |
| 컴포지트                      | - 객체 관계를 파일 트리 구조로 구성하여, 복합 객체와 단일 객체를 동일하게 취급 |                                                              |
| 브리지                        | - 구현부에서 추상층을 분리하여 결합도를 낮춘 패턴            |                                                              |
| 어댑터                        | - 호환성 없는 클래스의 인터페이스를 이용할 수 있게 변환      |                                                              |
| 데코레이터                    | - 객체 결합을 통해 기능을 확장                               |                                                              |
|                               |                                                              |                                                              |
| 디자인 패턴 - 행위 패턴       | 1. 중재자 (Mediator)<br />2. 인터프리터 (Interpreter)<br />3. 템플릿 메소드 (Template Method)<br />4. 옵저버 (Ovserver)<br />5. 비지터 (Visitor)<br />6. 커맨드 (Command)<br />7. 반복자 (Iterator)<br />8. 책임 연쇄 (Chain of Responsibility)<br />9. 상태 (State)<br />10. 전략 (Strategy)<br />11. 메멘토 (Memento) |                                                              |
| 중재자                        | - 객체 사이에 중재자를 두어 의존성을 줄이는 패턴             |                                                              |
| 인터프리터                    | - 여러 언어 구문을 해석할 수 있게 해주는 패턴                |                                                              |
| 템플릿 메소드                 | - 상위 클래스에서 기능을 정의하고, 하위 클래스에서 세부 처리 방법을 구체화하는 패턴<br />cf. 팩토리 메소드 - 상위 클래스에서 인터페이스 정의 후 하위 클래스에서 실제 생성 |                                                              |
| 옵저버                        | - 객체를 지켜보고 있다가, 객체의 상태가 변하면 그 객체에 의존하는 다른 객체들에게 변화된 상태를 전달 |                                                              |
| 비지터                        | - 처리 기능을 별도로 분리한 패턴<br />- 분리된 처리 기능은 클래스를 방문하여 수행 |                                                              |
| 커맨드                        | - 요청을 객체로 캡슐화하여, 각 요청이 들어오면 그에 맞는 서브 클래스 수행 |                                                              |
| 반복자                        | - 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴<br />- 내부 노출 없이 순차적 접근 가능 |                                                              |
| 책임 연쇄                     | - 한 객체가 요청을 처리하지 못하면, 연결된 객체로 넘어가 처리 |                                                              |
| 상태                          | - 객체의 상태를 캡슐화하고, 이를 참조해 동작을 다르게 처리   |                                                              |
| 전략                          | - 동일한 계열의 알고리즘을 캡슐화하고, 전약을 선택해 사용    |                                                              |
| 메멘토                        | - 특정 시점의 객체 내부 상태를 객체화하여, 해당 시점으로 되돌리는 기능을 제공 |                                                              |



# 2. 화면 설계

# 3. 데이터 입출력 구현

# 4. 통합 구현

# 5. 인터페이스 구현

# 6. 프로그래밍 언어 활용

# 7. SQL 응용

# 8. 서버 프로그램 구현

# 9. 소프트웨어 개발 보안 구축

# 10. 애플리케이션 테스트 관리

# 11. 응용 SW 기초 기술 활용

# 12. 제품 소프트웨어 패키징